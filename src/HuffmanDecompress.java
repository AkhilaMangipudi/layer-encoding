/* 
 * Reference Huffman coding
 * Copyright (c) Project Nayuki
 * 
 * https://www.nayuki.io/page/reference-huffman-coding
 * https://github.com/nayuki/Reference-Huffman-coding
 */

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.FileReader;
import java.io.BufferedReader;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;
import java.io.InputStreamReader;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.SdkClientException;
import com.amazonaws.auth.profile.ProfileCredentialsProvider;
import com.amazonaws.regions.Regions;
import com.amazonaws.services.s3.AmazonS3;
import com.amazonaws.services.s3.AmazonS3ClientBuilder;
import com.amazonaws.services.s3.model.GetObjectRequest;
import com.amazonaws.services.s3.model.ResponseHeaderOverrides;
import com.amazonaws.services.s3.model.S3Object;
import com.amazonaws.ClientConfiguration;

/**
 * Decompression application using static Huffman coding.
 * <p>Usage: java HuffmanDecompress InputFile OutputFile</p>
 * <p>This decompresses files generated by the "HuffmanCompress" application.</p>
 */
public class HuffmanDecompress {
	
	public void decompressFile(String fileName, String versionId) {
		//Using the given versionId, get the serialized string from S3 and deserialize it here to a tree
		String bucketName = "serverless685";
		String key = "huffman";
		S3Object fullObject = null;
		try {
			AmazonS3 s3Client = AmazonS3ClientBuilder.standard().withRegion(Regions.US_EAST_2)
				.withClientConfiguration(new ClientConfiguration().withMaxConnections(200)).build();
			/*
			double time = 0.0;
			int count = 100;
			long startTime = 0;
			long timeElapsed = 0;
			GetObjectRequest getReq = new GetObjectRequest(bucketName, key, versionId);
			for(int i = 0; i < count; i++) {
				startTime = System.nanoTime();
				S3Object obj = s3Client.getObject(getReq);
				timeElapsed = System.nanoTime() - startTime;
				time = time + timeElapsed;
			}
			System.out.println("Time taken to getObject from S3 is " + time / (count * 1000000) + " ms");
			*/
			fullObject = s3Client.getObject(new GetObjectRequest(bucketName, key, versionId));
			BufferedReader reader = new BufferedReader(new InputStreamReader(fullObject.getObjectContent()));
			String line = null;
			String content = "";
			while ((line = reader.readLine()) != null) {
				content = content + line;
			}
			//System.out.println("Object content from S3 is " + content);
			double time = 0.0;
                        int count = 1000;
                        long startTime = 0;
                        long timeElapsed = 0;
                        for(int i = 0; i < count; i++) {
                                startTime = System.nanoTime();
                              	Node root = unconvert(content);
                                timeElapsed = System.nanoTime() - startTime;
                                time = time + timeElapsed;
                        }
                        System.out.println("Time taken to deserialize the tree is " + time / (count * 1000000) + " ms");

			Node root = unconvert(content);
			//After getting the root node, read from the given input file, line by line and call the decoder
			//to decode the character and print it
			File file = new File(fileName);
			
			try (BufferedReader br = new BufferedReader(new FileReader(file))) {
				String line_2;
				while((line_2 = br.readLine()) != null) {
					//System.out.println("Input to decoder is " + line_2);
					decode(line_2, root);
					
				}
			}
		} catch (AmazonServiceException e) {
			//This call was transmitted successfully, but S3 couldn't process it
			e.printStackTrace();
		} catch (SdkClientException e) {
			//Amazon S3 couldn't be contacted for a response
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} 
	}
	
	public Node unconvert(String data) {
		return deserialize(new LinkedList<>(Arrays.asList(data.split(","))));
	}

	private Node deserialize(Queue<String> q) {
		String val = q.poll();
		if("#".equals(val)) return null;
		if("int".equals(val)) {
			//This is an internal node
			Node left = deserialize(q);
			Node right = deserialize(q);
			Node root = new InternalNode(left, right);
			return root;
		} else {
			//Leaf node
			Node root = new Leaf(val);
			return root;
		}
	}

	public void decode(String encoding, Node root) {
		if(root == null) {
			System.out.println("Root node is null");
			return;
		}
		char[] encodingChars = encoding.toCharArray();
		for(int i = 0; i < encodingChars.length; i++) {
			if (root instanceof InternalNode) {
				InternalNode node  = (InternalNode)root;
				if(encodingChars[i] == '0') {
					root = (Node)node.leftChild;
				} else {
					root = (Node)node.rightChild;
				}				
			}
			else if(root instanceof Leaf) {
				Leaf leaf = (Leaf)root;
				//System.out.println("Decoded symbol is " + leaf.symbol);
			}
		}
		if(root instanceof Leaf) {
			Leaf leaf = (Leaf)root;
			//System.out.println("Decoded symbol is " + leaf.symbol);
		}
	}	
}
